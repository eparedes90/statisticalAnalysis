---
title: "Análisis cuantitativo de la base de datos Visitas Remotas"
author: "Lucas Sempé, Peter Lloyd-Sherlock, Eduardo Paredes"
output:
  html_document: default
  word_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.height = 3, fig.width = 5, 
                      fig.align = "center",cache = T)
```

```{r, packages,message=FALSE, warning=FALSE}

library(dplyr)
library(readxl)
library(ggplot2)
library(stargazer)
library(scales)
library(ggExtra)
library(pander)
library(gtsummary)
library(ggthemes)
library(plyr)

```

```{r data, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

visitas <- readRDS("data_for_analysis/visitasCIES_clean15nov.Rdata")
pro_departamento <- read_xlsx("raw/Total_Programa_P65.xlsx", sheet = 1)
pro_provincia <- read_xlsx("raw/Total_Programa_P65.xlsx", sheet = 2)
pro_distrito <- read_xlsx("raw/Total_Programa_P65.xlsx", sheet = 3)

```

# Introducción

De cara a la inminencia de la expansión del COVID-19 en el país, se publica el decreto supremo 008-2020-SA (y posteriores modificaciones), de fecha 11-03-2020, que declara la emergencia sanitaria a nivel nacional, y establece medidas de prevención y control para evitar la propagación del virus. Ello ha implicado una serie de modificaciones de los organismos del Estado para la atención a sus usuarios, la mitigación de efectos negativos (económicos, sociales, y en salud) a causa de la pandemia y la suspensión de actividades, así como la adaptación de los servicios. 

Respondiendo a la circunstancia, el decreto supremo 004-2020-MIDIS, de fecha 13-03-2020, autoriza al Programa Pensión 65 a efectuar transferencias monetarias adelantadas, correspondiente a la relación bimestral de usuarios de los periodos marzo - abril y mayo - junio de 2020, según el total de usuarios abonados al mes de marzo de 2020, de acuerdo con el Padrón General de Hogares – PGH, que reúnan los requisitos de afiliación establecidos en su norma de creación. Adicionalmente, mediante Resolución Directoral 050-2020-MIDIS/P65-DE, se aprueba, el día 14 de Marzo, el [Protocolo de Visitas Domiciliarias](https://cdn.www.gob.pe/uploads/document/file/576672/Protoloco_de_visitas_domiciliarias_a_personas_adultas_mayores__usuarias_de_Pensi%C3%B3n_65_para_la_prevenci%C3%B3n_del_coronavirus.pdf.pdf) a Personas Adultas Mayores Usuarias de Pensión 65 para la Prevención de Coronavirus (COVID-19).

Considerando que la morbilidad a causa de la pandemia ocurre en forma desproporcionada en la población adulta mayor, donde hasta el momento presente, el 69.7% de los fallecidos oficialmente reconocidos corresponde a dicho estrato poblacional , cobra mayor relevancia estudiar las acciones propuestas por el Programa Pensión 65 en el contexto de la pandemia. 

El diálogo sostenido con el área de evaluación del MIDIS, y la contraparte del Programa Pensión 65 indicó que las distintas actividades que el Programa realizaba de forma habitual en términos de articulación con el área de salud se han dejado de hacer, mientras que las estrategias se han adaptado a la virtualidad. Ello por el gran riesgo que implica la población objetivo del Programa, así como por el cuidado hacia los trabajadores del Programa y sus familias. 

Dentro de las distintas actividades del Programa durante la época de pandemia, resalta la creación del Protocolo de Visitas Domiciliarias a Personas Adultas Mayores Usuarias de Pensión 65 para la Prevención de Coronavirus (COVID-19) tiene como objetivo el “brindar educación en prácticas de cuidado que disminuyan el riesgo vinculado al coronavirus, y de ser el caso, para la derivación oportuna al sector Salud para su atención”, buscando “potenciar la articulación con el sector Salud para la adopción de acciones preventivas para disminuir (el) riesgo de contagio en las personas adultas mayores del Programa Pensión 65”.


El siguiente documento tiene como finalidad presentar el análisis cuantitativo de la base de datos **Visitas Remotas**, elaborado a partir de las llamadas a los beneficiarios del Programa Pensión 65 (P65) desde el inicio de la implementación (marzo) hasta el 15 de noviembre del 2020, enfocándonos en el análisis descriptivo de las llamadas, así como la asociación de las mismas a variables de interés de la política pública en los niveles departamentales, provinciales y distritales. 

Con ello se busca cumplir con dos objetivos concurrentes. Por un lado, identificar casos que puedan ser usados en la fase cualitativa de la presente evaluación, y por otro lado, explorar tendencias que permitan a P65 realizar ajustes en su mecanismo de recolección de datos así como de análisis de los mismos.


# Métodos

Con la finalidad de realizar el análisis de las variables relevantes de la base de datos **Visitas Remotas** se hizo, en primer lugar, una inspección de las respuestas de cada variable de dicha de base de datos para evaluar la calidad de los datos. Se identificaron así casos de variables con valores perdidos o considerados fuera de lo esperado.

En segundo lugar, luego de realizar la limpieza correspondiente, se unieron a ella otras bases como el padrón de beneficiarios del programa Pensión 65 para analizar la asociación de las llamadas a otros indicadores importantes. Este análisis se realizó en los niveles departamental, provincial y distrital. Se adjuntaron algunos indicadores de pobreza (Índice de desarrollo humano y Necesidades básicas insatisfechas) de salud y de ruralidad, los cuales fueron ponderados por la población de la unidad de análisis.

# Resultado

A continuación, presentamos un análisis descriptivo de las principales variables encontradas, lo que nos permitirá luego detectar casos a ser explorados en la fase cualitativa de la presente evaluación.

## Magnitudes 

```{r magintudes 1, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#variable.names(visitas)

nn<-nrow(visitas)
nn1<-ncol(visitas)-4
ntel<-table(visitas$usuario_acceso_celular)[2]
nvis<-table(visitas$usuariovisitado)[2]
propv<-round(nvis/ntel,2)*100

```

La base de datos contiene `r nn` observaciones y `r nn1` variables, y comprende información desde el inicio de la implementación del servicio hasta el día 15 de Noviembre, fecha en la que el equipo del Programa P65 nos remitió la base de datos anonimizada. La siguente tabla nos muestra que 83% de usuarios que cuenta con línea telefónica ha recibido al menos una visita remota, como se observa en la siguiente tabla.

```{r magnitudes 2, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

visitas %>% dplyr::select(usuario_acceso_celular,usuariovisitado) %>%
         tbl_cross(percent = "row")

```

En el siguiente gráfico combinamos información de ENAHO 2019 sobre proporción de hogares con al menos teléfono celular (rojo) y el porcentaje de beneficiarios de Pensión 65 con un teléfono reportado (verde). Lo primero llamativo es que las diferencias en términos muestrales de posesión de teléfonos celulares varía entre 78.7% en Loreto a 96.2% en Arequipa. Por otro lado, el porcentaje de usuarios con teléfonos reportados varía entre 36% en el caso de Cusco y 84% en caso de Amazonas. Aunque se esperaría una correlación robusta entre ambos (debido a Ley de Grandes Números), ello no es el caso, r(25)=.13. Ello sugeriría la existencia de disparidades en cuanto a la obtención de teléfonos por parte de las diversas regiones del país, donde Ancash, Huancavelica, Amazonas y Apurimac sobresalen positivente mientras que Puno y Cusco sobresalen negativamente.

```{r magnitudes 3, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE }

visitas.prop.usua.tel <- visitas %>%                group_by(departamento,usuario_acceso_celular) %>%
  dplyr::summarise(n = n()) %>%
  group_by(departamento) %>%
  mutate(prop = n / sum(n)*100) %>%
  filter (usuario_acceso_celular=="SI") 

enahotelefonos <- read_excel("data_for_analysis/enahotelefonos.xlsx")

cora<-visitas.prop.usua.tel %>% left_join(enahotelefonos)

#cor.test(cora$prop.t,cora$prop.tel)

#visitas.prop.tel %>% left_join(enahotelefonos) %>% ggplot()+geom_point(aes(prop.t,prop.tel))
  
ggplot()+
   geom_point(data=visitas.prop.usua.tel,aes(x=reorder(departamento,-prop),
                                        y=prop,colour="P65"))+
  geom_point(data=enahotelefonos,aes(x=departamento,
                                   y=prop.tel,colour="ENAHO"))+
   theme(axis.text.x = element_text(size = 8,angle = 45,vjust = .5),
         legend.position = "bottom")+
     scale_colour_discrete(name="Proporción teléfono") + labs(x="Departamento",y="%")



```

## Visitas remotas

Se puede observar en el siguiente gráfico el porcentaje de usuarios que cuentan con teléfono registrado en el Programa que fueron visitados (rojo) y el porcentaje total de usuarios visitados (verde). Mientras los valores de eficiencia llegan al 100% en casos como Huancavelica y San Martín, y son menores a 70% en Piura y Ucayali, los valores ajustados a la totalidad de la población muestran al departamento de Ancash sobresaliendo con un porcentaje cercano al 80% y Cusco con un porcentaje cercano al 30%.


```{r visitas remotas por benef 1, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

visitas.prop<-visitas %>%
  filter(usuario_acceso_celular=="SI") %>%
  dplyr::group_by(departamento,usuario_acceso_celular,usuariovisitado) %>%
  dplyr::summarise(n = n()) %>% 
  dplyr::group_by(departamento) %>%
  dplyr::mutate(prop.t = n / sum(n)*100) %>%
  dplyr::filter (usuariovisitado=="SI")


visitas %>% 
  group_by(departamento,usuario_acceso_celular,usuariovisitado) %>%
    dplyr::summarise(n = n()) %>%
   group_by(departamento) %>%
   dplyr::mutate(propa = n / sum(n)*100,
          total=sum(n)) %>% filter(usuario_acceso_celular=="SI"  &
                                     usuariovisitado=="SI") %>% 
  ggplot() + 
    geom_point(data=visitas.prop, aes(x=reorder(departamento,-prop.t),
                                      y=prop.t,  
                                    colour="% visitas /  usuarios c/ tel"))+
  geom_point(aes(y=propa,x=departamento,
                 colour="% visitas / usuarios total"))+
       theme(axis.text.x = element_text(size = 8,angle = 45,vjust = .5),
             legend.position = "bottom")+
   scale_colour_discrete(name="Proporción llamadas") +
  labs(x="Departamento",y="%")

```


Finalmente, el siguiente gráfico muestra el número de beneficiarios y visitas, que varía entre 1 y 31 llamadas. Las regiones de San Martín, Cajamarca (mayor número de beneficiarios) y Ancash concentran el 39.4% de las llamadas realizadas (164,873 de 417,611), mientras que los departamentos con menos llamadas son Callao, Tacna y Madre de Dios, departamentos que se caracterizan también por estar entre aquellos con la menor cantidad de beneficiarios.

```{r total visitas , echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

tot<-visitas %>% group_by(departamento) %>%
  dplyr::summarise(n=n())

#visitas %>%   filter (usuario_acceso_celular=="SI" & numerodevisitas>0) %>% summarise(n = sum(numerodevisitas)) 

visitas %>%   group_by(departamento) %>%
  filter (usuario_acceso_celular=="SI" & numerodevisitas>0) %>%
       dplyr::summarise(n = sum(numerodevisitas)) %>% ggplot()+
  geom_point(aes(x=reorder(departamento,-n),y=n,colour="total llamadas"))+
  geom_point(data=tot,aes(departamento,n,colour="beneficiarios"))+
       theme(axis.text.x = element_text(size = 8,angle = 45,vjust = .5),
             legend.position = "bottom")+
  labs(x="Departamento",y="Totales")


```

Los departamentos de San Martín y Moquegua presentan la mayor cantidad de visitas remotas por beneficiario, con un promedio cercano a 3.9 y 3.0 llamadas respectivamente, mientras que los departamentos de Callao, Puno, Apurimac y Ancash son aquellos con menor media, cercana a 1.2 llamadas por beneficiario.

```{r visitas remotas por benef 2, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

visitas_remotas <- visitas %>% filter (usuariovisitado=="SI") %>%
  group_by(departamento) %>%
  dplyr::summarise(total = sum(numerodevisitas), min = min(numerodevisitas), q25 = quantile(numerodevisitas, 0.25), mean = mean(numerodevisitas), median = median(numerodevisitas), q75 = quantile(numerodevisitas, 0.75), max = max(numerodevisitas))
visitas_remotas$Departamento <- factor(visitas_remotas$departamento, levels = visitas_remotas$departamento)
visitas_remotas_1 <- visitas_remotas[order(visitas_remotas$mean), ]
visitas_remotas_1$Departamento <- factor(visitas_remotas_1$Departamento, levels = visitas_remotas_1$Departamento)
#print(visitas_remotas[order(visitas_remotas$mean), ])
#print(visitas_remotas[order(visitas_remotas$mean, decreasing = T), ])
#visitas_remotas[order(visitas_remotas$n, decreasing = T), ]
#print(visitas_remotas[order(visitas_remotas$n, decreasing = F), ])

#Plot de puntos de número de visitas por beneficiado
theme_set(theme_classic())
ggplot(visitas_remotas_1, aes(x=Departamento, y=mean)) + 
  geom_point(col="blue", size=3) +   
  geom_segment(aes(x=Departamento, 
                   xend=Departamento, 
                   y=min(mean), 
                   yend=max(mean)), 
               linetype="dashed", 
               size=0.1) +   
  labs(title="Promedio de visitas remotas por encuestado",
       subtitle = "Nivel departamento",
       x = "",
       y = "")  +
  coord_flip()

```

## Edad 

<!-- revisar edades  > 111 años, sera error? -->
<!-- Al parecer no, tanto en la antigua como en la nueva
base de datos se tienen edades superiores a 111 años-->

El promedio de edad de los beneficiarios visitados es de 76.3 años con una desviación estándar de 6.6 años. Analizando los datos a nivel departamental, encontramos que la mayor media de edad de encuestados es Moquegua con 78.2 años, mientras que el de menor media es Loreto con 74.8 años. 
El siguiente gráfico destaca el promedio de edad de los beneficiarios visitados (rojo) y el total de beneficiarios (verde), donde se observan casos como Puno y Cusco donde el promedio de la poblacion visitada es menor al promedio total por al menos 1 año, mentras que en el resto de casos, las diferencias son menos relevantes. Madre de Dios, Moquegua y Amazonas destacan como departamentos donde el promedio de edad de los que recibieron visitas es superior al promedio general del departamento.

```{r analisis descriptivo, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#variable.names(visitas)


edad1 <- visitas %>% filter (usuariovisitado=="SI")%>%
  dplyr::summarise(n. = n(), min = min(edad2), q25 = quantile(edad2, 0.25), mean = mean(edad2), median = median(edad2), q75 = quantile(edad2, 0.75), max = max(edad2),sd=sd(edad2))

edad2 <- visitas %>%
  group_by(departamento) %>% filter (usuariovisitado=="SI")%>%
  dplyr::summarise(n. = n(), min = min(edad2), q25 = quantile(edad2, 0.25), mean = mean(edad2), median = median(edad2), q75 = quantile(edad2, 0.75), max = max(edad2))

edad2 <- edad2[order(edad2$mean), ]
edad2$Departamento <- factor(edad2$departamento, levels = edad2$departamento)
#head(edad2[order(edad2$mean), ])
#head(edad2[order(edad2$mean, decre
#Plot de barras
#ggplot2::ggplot(edad2, aes(x = Departamento, y = mean)) + geom_bar(stat = "identity", width=.5, fill="tomato3") +labs(title="Promedio de edad") +  theme(axis.text.x = element_text(angle=70, vjust=0.5))

#Plot de puntos

edad3 <- visitas %>%
  group_by(departamento) %>% 
  dplyr::summarise(n. = n(), min = min(edad2), q25 = quantile(edad2, 0.25), mean = mean(edad2), median = median(edad2), q75 = quantile(edad2, 0.75), max = max(edad2))

theme_set(theme_classic())
ggplot(edad2, aes(x=Departamento, y=mean,colour="Beneficiarios visitados")) + 
  geom_point(col="tomato2", size=3) +   
  geom_segment(aes(x=Departamento, 
                   xend=Departamento, 
                   y=min(mean), 
                   yend=max(mean)), 
               linetype="dashed", 
               size=0.1) +   
  labs(title="Promedio de edad",
       subtitle = "Nivel departamento",
       x = "",
       y = "")  +
  coord_flip()+
  geom_point(data=edad3,aes(departamento,y=mean,colour="Total beneficiarios"))+
  theme(legend.position = "bottom")

```

## Variables de salud

<!-- ACA ME QUEDE, por favor actualiza hacia adelante. revisa los comentarios. la parte inferencial la reviso luego, la trabajamos para el informe final. -->

A los beneficiarios (o sus familiares)  se les preguntó por información respecto a la salud. Agregando los resultados a nivel departamental, se encontró que en Tumbes se tiene el mayor porcentaje 5.6% de encuestados que manifiesta tener diabetes. 
Así también este departamento tiene el mayor porcentaje de encuestados (25%) con hipertensión. El departamento de Cajamarca reporta ser el más alto (3.7%) con encuestados con una enfermedad cardiovascular, mientras que Lambayeque es aquel con el mayor porcentaje (2.5%) de enfermedad pulmonar. Asimismo, este departamento es quien tiene el mayor porcentaje (0.8%) de encuestados con cáncer. 

```{r vars dicotomicas, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#intente hacer mediante una ruta mas simple pero al tener caracteres y no numericos, no me ligo. hay que corregir esto.

visitas %>% 
  dplyr::select(c(2,17:27)) %>% 
  tbl_summary(by=departamento, missing = "no",
              percent = "column")
#EPE: ¿Quieres dejar esta tabla de resumen? Pregunto porque me parece muy larga y ancha


# EPE: Dejé esta tabla. Había un error en la tabla anterior que hice porque no contaba los NO SABE. A menos que se tomen los NO SABE como NA y haga una tabla con los departamentos con los porcentajes más altos de cada una de las variables. 

#¿Dependiendo cómo se vea la tabla en el reporte (tal vez el tamaño obstruya) le agrego una tabla de departamentos con los máximos?


```

## Indicadores COVID

Moquegua es el departamento con el mayor porcentaje de encuestados que indicaron haber tenido contacto con una persona COVID positivo (1.3%). Asimismo, esta región es aquella con el mayor porcentaje de encuestados con una persona en casa diagnosticada con la COVID (0.9%). Por último, Tacna es aquel con el mayor porcentaje de encuestados que han acudido a un establecimiento de salud (4.0%).

```{r indicadores COVID clean, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

colnames(visitas)[28] <- "contacto_covid"
colnames(visitas)[29] <- "encasaalguien_covid"
colnames(visitas)[30] <- "acudidoestablecimiento_covid"

visitas %>% 
  dplyr::select(2, 28:30) %>% 
  tbl_summary(by=departamento,missing = "no",
              percent = "column")


```


## Riesgo

<!-- quizas lo mas importante de esta herramienta es la identificacion de riesgo. debe estar relacionado a comorbilidad, signos de alarma, y estado de salud. hacer analisis de estas variables. -->

```{r riesgo 1, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#Codificación de estas variables

visitas$riesgo <- mapvalues(visitas$riesgo,
                            c("Alto", "Medio", "Bajo"),
                            c(3, 2, 1))
visitas$estado_salud <- mapvalues(visitas$estado_salud,
                            c("NO", "SI"),
                            c(0, 1))
visitas[, c("riesgo", "estado_salud", "comorbilidad")] <-  apply(visitas[, c("riesgo", "estado_salud", "comorbilidad")], 2, function(x) ordered(x))

#correlacion spearman
cor_riesgo_comorb <- round(cor(as.numeric(visitas$riesgo),
                              as.numeric(visitas$comorbilidad),
                              method = "spearman",
                              use = "complete.obs"), 3)

cor_riesgo_sign <- round(cor(as.numeric(visitas$riesgo),
                            as.numeric(visitas$sign_alarma),
                            method = "spearman",
                            use = "complete.obs"), 3)

cor_riesgo_estado <- round(cor(as.numeric(visitas$riesgo),
                            as.numeric(visitas$estado_salud),
                            method = "spearman",
                            use = "complete.obs"), 3)

#warning! p-value


```


La variable riesgo reporta al departamento de Tumbes como aquel con mayor porcentaje (30%) de encuestados con un nivel alto de riesgo, mientras que Ica con 6.5% como el de menor porcentaje. 

Esta variable tiene una correlación positiva (`r cor_riesgo_comorb`) - método de correlación de Spearman-  con el nivel de comorbilidad que presenta, así como con el nivel de estado de salud (`r cor_riesgo_estado`) y con el nivel de signo de alarma (`r cor_riesgo_sign`). Esto explica que el nivel de riesgo tiene una correlación más alta con el nivel de comorbilidad que presenta el encuestado que con las otras dos variables, por lo que esta tendría un mayor peso al momento de calificar el nivel de riesgo. 


```{r riesgo 2, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

visitas %>% 
  dplyr::select(2, 44:46, 49) %>% 
  tbl_summary(by=departamento,missing = "no",
              percent = "column")


```



## Total de llamadas y Número de usuarios

<!-- TODA ESTA SECCION (A NIVEL DEPARTAMENTAL) YA ESTA ARRIBA, NO? SE BORRA NOMAS? CREO QUE SE PUEDE HACER SOLO A NIVEL PROVINCIAL alla arriba. -->

<!--No es lo mismo cobertura de llamadas a visitas remotas. Visitas remotas es el número de llamadas realizadas a un mismo beneficiario, mientras que cobertura de llamadas es la proporción del total de llamadas y el total de benficiarios en la unidad de análisis -->

La proporción entre el número de llamadas y número de usuarios da cuenta de la cobertura de las visitas domiciliarias. Encontramos, a nivel departamental, una correlación que puede ser considerada como robusta entre ambas, r(23) = .71, p < .001. Sin embargo, el gráfico da cuenta que departamentos como San Martín y Áncash han tenido una performance por encima de la línea de predicción, mientras que Cusco, Piura y Puno han tenido una performance menor a la línea de predicción. 

<!--agrego la programación de la base 1 para correr los demás chunks de manera más rápida-->


```{r cor proporcion llamadas, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#1. Proporción de llamadas ~ N de usuarios departamento/provincia/distrito

sumallamadas <- sum(visitas$numerodevisitas)
visitas$UBIGEO_departamento<-substr(visitas$codigo_ubigeo, 0, 2)
visitas$UBIGEO_provincia<-substr(visitas$codigo_ubigeo, 0, 4)
colnames(visitas)[1]<- "UBIGEO_distrito"
llamadas_departamento <- aggregate(visitas$numerodevisitas, by = list(visitas$UBIGEO_departamento), sum, na.rm=T)
llamadas_departamento$`Proporcion_llamadas`<-NA
llamadas_departamento[, 3] <- llamadas_departamento[, 2]/sumallamadas
colnames(llamadas_departamento)[1]<-"UBIGEO_departamento"
colnames(pro_departamento)[1]<-"UBIGEO_departamento"
llamadas_departamento <- left_join(llamadas_departamento, pro_departamento, by="UBIGEO_departamento")

colnames(llamadas_departamento)[2]<-"Total_llamadas"

cor_total <- cor.test(llamadas_departamento$Total_llamadas, llamadas_departamento$PENSION_65)

plot_llamadas_pension_d <- ggplot(data = llamadas_departamento, aes(y=Proporcion_llamadas,x= PENSION_65,label=Departamento)) + geom_point()+
  labs(title = "Proporción de llamadas",
       subtitle = "Nivel departamento",
       y = "Número de llamadas",
       x = "Número de beneficiarios")+
  geom_smooth(method = "lm", se = FALSE)+ 
  geom_text(vjust = 2, nudge_x = 3,size=2,check_overlap = F)

#print(plot_llamadas_pension_d)

plot_total.llamadas_pension_d <- ggplot(data = llamadas_departamento, aes(y=Total_llamadas,x= PENSION_65,label=Departamento)) + 
  geom_point()+
  labs(title = "Proporción de llamadas",
       subtitle = "Nivel departamento",
       y = "Número de llamadas",
       x = "Número de beneficiarios")+ 
  geom_smooth(method = "lm", se = FALSE)+ 
  geom_text(hjust = 1, nudge_y = 1,size=4,check_overlap = T)

print(plot_total.llamadas_pension_d)

```



```{r proporcion provincia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

## provincia
llamadas_provincia <- aggregate(visitas$numerodevisitas, by = list(visitas$UBIGEO_provincia), sum, na.rm=T)
colnames(llamadas_provincia)[1]<-"UBIGEO_provincia"
colnames(pro_provincia)[1]<-"UBIGEO_provincia"
llamadas_provincia <- left_join(llamadas_provincia, pro_provincia, by="UBIGEO_provincia")
colnames(llamadas_provincia)[2]<-"Total_llamadas"
cor_total_provincia <- cor.test(llamadas_provincia$Total_llamadas, llamadas_provincia$PENSION_65)

cor_total_provincia_est<-cor(llamadas_provincia$Total_llamadas, llamadas_provincia$PENSION_65)


plot_total.llamadas_pension_provincia <- ggplot(data = llamadas_provincia, aes(y=Total_llamadas,x= PENSION_65,label=Provincia)) + 
  geom_point(aes(color = Departamento))+
  labs(title = "Proporción de llamadas",
       subtitle = "Nivel provincia",
       y = "Número de llamadas",
       x = "Número de beneficiarios")+ 
  geom_smooth(method = "lm", se = FALSE)+ 
  geom_text(vjust = 1.5, nudge_y = 0.2, size=3, check_overlap = T)+
   theme(legend.position='none')

print(plot_total.llamadas_pension_provincia)

```

A nivel provincial existe una correlación que puede ser considerada como robusta entre ambas variables, r(194) = `r cor_total_provincia_est`, p < .001. No obstante, las provincias de Lima y Moyobamba  se presentan notoriamente por encima de la línea de predicción; análogamente, Piura, por debajo de la misma. 


```{r proporcion distrito, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

llamadas_distrito <- aggregate(visitas$numerodevisitas,
                               by = list(visitas$UBIGEO_distrito), 
                               sum, na.rm = T)
colnames(llamadas_distrito)[1]<-"UBIGEO_distrito"
colnames(pro_distrito)[1]<-"UBIGEO_distrito"
llamadas_distrito <- left_join(llamadas_distrito,
                               pro_distrito,
                               by="UBIGEO_distrito")
colnames(llamadas_distrito)[2]<-"Total_llamadas"
cor_total_distrito <- cor.test(llamadas_distrito$Total_llamadas,
                               llamadas_distrito$PENSION_65)
cor_total_distrito_est <- cor(as.numeric(llamadas_distrito$Total_llamadas),
                              as.numeric(llamadas_distrito$PENSION_65))
plot_total.llamadas_pension_distrito <- ggplot(data = llamadas_distrito,
                                               aes(y=Total_llamadas,
                                                   x= PENSION_65,
                                                   label=Distrito)) +
  geom_point(aes(color = Departamento)) +
  labs(title = "Proporción de llamadas",
       subtitle = "Nivel distrito",
       y = "Número de llamadas",
       x = "Número de beneficiarios")+ 
  geom_smooth(method = "lm", se = FALSE)+ 
  geom_text(vjust = 1.5,
            nudge_y = 0.2,
            size=3,
            check_overlap = T) +
  theme(legend.position='none')

print(plot_total.llamadas_pension_distrito)

```

Finalmente, a nivel distrital existe una correlación que puede ser considerada como ligeramente alta entre ambas variables, r(1845) = `r cor_total_distrito_est`, p < .001. Por otro lado, se observan muchos distritos que están notoriamente por encima y por debajo del gráfico de la regresión lineal. Resalta negativamente Bambamarca; mientras que positivamente, Carabayllo, Moyobamba y Moquegua.

## Cobertura de llamadas

Para facilitar el análisis, proponemos la creación de la variable **Cobertura de llamadas**, que consiste en la proporción del número de visitas remotas divido entre el número de personas beneficiadas al programa según el padrón de beneficiarios. Las unidades de análisis serán los tres niveles departamental, provincial y distrital. 

La fórmula a nivel distrital, por ejemplo, tiene la siguiente notación:

$Cobertura_{distrital}  = \frac{NumeroLlamadas_{distrital}}{TotalBeneficiarios_{distrital}}$

Con la finalidad de presentar aquellos los distritos con mejores y peores índices de cobertura de llamadas, se presenta a continuación un gráfico de barras con los valores extremos.

Así, encontramos que los distritos con menor cobertura de llamadas son los que corresponden  a los distritos de Churua, Anco y Chungui, con valores de 0, mientras que aquellos con mayor cobertura son los siguientes: Habana (Provincia Chachapoyas, Amazonas), Moyobamba y El Eslabón tienen valores superiores a 4.

```{r cobertura de llamadas head box plot, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}

llamadas_departamento$cobertura <- llamadas_departamento$Total_llamadas/llamadas_departamento$PENSION_65

llamadas_provincia$cobertura <- llamadas_provincia$Total_llamadas/llamadas_provincia$PENSION_65

llamadas_distrito$Total_llamadas <- as.numeric(llamadas_distrito$Total_llamadas)
llamadas_distrito$PENSION_65 <- as.numeric(llamadas_distrito$PENSION_65)

llamadas_distrito$cobertura <- llamadas_distrito$Total_llamadas/llamadas_distrito$PENSION_65

llamadas_distrito <- llamadas_distrito[order(llamadas_distrito$cobertura), ]
llamadas_distrito$UBIGEO_distrito <- factor(llamadas_distrito$UBIGEO_distrito, levels = llamadas_distrito$UBIGEO_distrito)
theme_set(theme_bw())

# Plot
plot_head_cobertura <- ggplot(head(llamadas_distrito), aes(x=UBIGEO_distrito, y=cobertura, label = Distrito)) + 
  geom_point(size=1.5) + 
  geom_segment(aes(x=UBIGEO_distrito, 
                   xend=UBIGEO_distrito, 
                   y=0, 
                   yend=cobertura)) + 
  labs(title="Menor cobertura de llamadas", 
       subtitle="Nivel distrito",
       x="Ubigeo",
       y="Cobertura") + 
  theme(axis.text.x = element_text(angle=40, vjust=0.6))+
  geom_text(vjust = 0.005, nudge_y = 0.0001, size=2.5, check_overlap = T)
print(plot_head_cobertura)

```


```{r cobertura de llamadas tail plot, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}

# plot_tail_cobertura
plot_tail_cobertura <- ggplot(tail(llamadas_distrito), aes(x=UBIGEO_distrito, y=cobertura, label = Distrito)) + 
  geom_point(size=1.5) + 
  geom_segment(aes(x=UBIGEO_distrito, 
                   xend=UBIGEO_distrito, 
                   y=0, 
                   yend=cobertura)) + 
  labs(title="Mayor cobertura de llamadas", 
       subtitle="Nivel distrito",
       x="Ubigeo",
       y="Cobertura") + 
  theme(axis.text.x = element_text(angle=40, vjust=0.6))+
  geom_text(vjust = 0.1, nudge_y = 0.1, size=2.5, check_overlap = T)
print(plot_tail_cobertura)

```


### Cobertura y agencias/transportadora

<!-- Lucas: Adicionalmente, hay una nueva variable tipo_centro poblado. hacer analisis similar de llamadas y de poblacion total de P65-->
<!-- EPE: No entiendo cómo realizar este análisis que mencionas. La variable centro poblado tiene 2 niveles: amazónico y andino. ¿Se busca analizar la correlación de cobertura y centro poblado? -->

Como un proxy de la división urbana y rural, utilizamos la distribución de usuarios que utilizan agencias del Banco de la Nación, en áreas urbanas y los que reciben el beneficio mediante transportes de valores, en áreas rurales.

Existe una correlación negativa, aunque muy débil entre el Número de entregas en agencia y la cobertura de llamadas a nivel distrital, (r(1631) = -0.13, p <0.001). De igual forma se observa en con el número de entregas mediante la transportadora, (r(568) = -0.22, p < 0.001)

```{r agencia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
# Read bbdd
agencia_limacallao <- readxl::read_xlsx("raw/Cronograma-Agencias-RBU-ND-2020-P65_FINAL.xlsx", sheet = 2)
agencia_provincia <- readxl::read_xlsx("raw/Cronograma-Agencias-RBU-ND-2020-P65_FINAL.xlsx", sheet= 1)
transportadora <- readxl::read_xlsx("raw/transportadora.xlsx")

# Unión de bbdd de agencia de lima y provincia
agencia_provincia$`CENTRO POBLADO`<-as.character(agencia_provincia$`CENTRO POBLADO`)
agencia <- rbind(agencia_limacallao[, 1:12], agencia_provincia[, 1:12])
colnames(agencia)[8] <- "UBIGEO_distrito"
colnames(agencia)[11] <- "N_usuarioP65_agencia"

# N de entregas en agencia por distrito
agencia_clean <- aggregate(agencia$N_usuarioP65_agencia, by = list(agencia$UBIGEO_distrito), sum, na.rm=T)
colnames(agencia_clean)[1] <- "UBIGEO_distrito"
colnames(agencia_clean)[2] <- "N_usuarioP65_agencia"
rural <- left_join(llamadas_distrito, agencia_clean, by = "UBIGEO_distrito")

# Plot de Entregas en agencia vs cobertura
plot_rural_1 <- ggplot(rural, aes(cobertura, N_usuarioP65_agencia, label = Distrito))+geom_point()+ 
  labs(title="Número de entregas en agencia vs. Cobertura", 
       subtitle="Nivel distrito",
       x="Cobertura",
       y="Entregas en agencia")+ 
  geom_smooth(method = "lm", se = FALSE)+
  geom_text(vjust = 1.5, nudge_y = 0.2, size=3, check_overlap = T)
print(plot_rural_1)

#test de correlación de Agencia y cobertura
cortest_agencia_cobertura <- cor.test(rural$cobertura, rural$N_usuarioP65_agencia)

```


```{r transportadora, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

# Limpieza de la bbdd de transportadora
transportadora$DEPARTAMENTO <- toupper(transportadora$DEPARTAMENTO)
transportadora$PROVINCIA <- toupper(transportadora$PROVINCIA)
transportadora$DISTRITO <- toupper(transportadora$DISTRITO)
colnames(transportadora)[1] <- "Departamento"
colnames(transportadora)[2] <- "Provincia"
colnames(transportadora)[3] <- "Distrito"
colnames(transportadora)[6] <- "N_usuarioP65_transp"

# Union de bbdd de transportadora y llamadas por distrito
transportadora$ubigeo <- paste(transportadora$Departamento, transportadora$Provincia, transportadora$Distrito, sep = "")
transportadora_clean <- aggregate(transportadora$N_usuarioP65_transp, by = list(transportadora$ubigeo), sum)
colnames(transportadora_clean)[1] <- "ubigeo"
colnames(transportadora_clean)[2] <- "N_usuarioP65_transp"
llamadas_distrito$ubigeo <- paste(llamadas_distrito$Departamento, llamadas_distrito$Provincia, llamadas_distrito$Distrito, sep = "")
rural_2 <- left_join(llamadas_distrito, transportadora_clean, by = "ubigeo")

# Plot de cobertura vs transportadora
plot_rural_2 <- ggplot(rural_2, aes(cobertura, N_usuarioP65_transp, label = Distrito))+geom_point()+ 
  labs(title="Número de entregas transportadora vs. Cobertura", 
       subtitle="Nivel distrito",
       x="Cobertura de llamadas",
       y="Entregas transportadora")+ 
  geom_smooth(method = "lm", se = FALSE)+
  geom_text(vjust = 1.5, nudge_y = 0.2, size=3, check_overlap = T)
print(plot_rural_2)

#test de correlación de Transp y cobertura
cortest_transp_cobertura <- cor.test(rural_2$cobertura, rural_2$N_usuarioP65_transp)

```

Debido a que las variables **Entregas transportadora** y **Entregas en agencia** fueron elegidas como proxys de ruralidad y urbanidad (respectivamente), se desprende que no hay mayores diferencias en la relación de ambos contextos con la cobertura de llamadas. En otras palabras, la ruralidad o la urbanidad parecen no ser factores de concentración de llamadas en los distritos.

### Cobertura e indicadores de pobreza

A nivel departamental, el Índice de Desarrollo Humano (IDH) tiene una baja correlación con la variable **Cobertura de llamadas**. Además ésta no es estadísticamente significativa (r(194) = 0.33, p > 0.1). Así, se observa que los departamentos de Lima y Arequipa son aquellos con mayor distancia de alejamiento por encima de la línea de predicción; mientras que Huancavelica es aquel con menor performance.

```{r pobreza, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#Unir base de IDH
idh <- readxl::read_xlsx("raw/tt_IDH-y-Componentes-2003-2019_original.xlsx", sheet=3)
idh$departamento <- substr(idh$UBIGEO, 0, 2)
idh$provincia <- substr(idh$UBIGEO, 3, 4)
idh$distrito <- substr(idh$UBIGEO, 5, 6)
idh_provincia <- idh[idh$distrito == "00" & !idh$provincia == "00" & !is.na(idh$provincia), ]
idh_provincia$UBIGEO_provincia <- substr(idh_provincia$UBIGEO, 0, 4)


```


```{r pobreza departamento, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#IDH a nivel departamento
idh_departamento <- idh[idh$provincia == "00" & !is.na(idh$departamento), ]
idh_departamento$UBIGEO_departamento <- substr(idh_departamento$UBIGEO, 0, 2)

pobreza_departamento <- left_join(llamadas_departamento, idh_departamento, by = "UBIGEO_departamento")
plot_idh_departamento <- ggplot2::ggplot(pobreza_departamento, aes(cobertura, IDH, label = Departamento)) + 
  geom_point() +
  labs(title = "IDH vs Cobertura",
       subtitle = "Nivel departamento",
       x = "Cobertura",
       y = "IDH")+
  geom_smooth(method = "lm", se = FALSE)+
  geom_text(vjust = 0.01, nudge_y = 0.01, size=3, check_overlap = T)
ggMarginal(plot_idh_departamento, type = "boxplot")

cortest_idh_departamento <-cor.test(pobreza_departamento$cobertura, pobreza_departamento$IDH)


```


Por otro lado, a nivel provincial, se reporta una  correlación positiva y baja entre cobertura de llamadas e IDH, r(22) = 0.21 (p < 0.01). Ello sugiere la ausencia de una priorización de las llamadas a provincias con más pobreza.

```{r pobreza provincia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#IDH provincia
pobreza_provincia <- left_join(llamadas_provincia, idh_provincia, by = "UBIGEO_provincia")

plot_idh_provincia <- ggplot2::ggplot(pobreza_provincia, aes(cobertura, IDH, label = Provincia)) + 
  geom_point() + 
  labs(title = "IDH vs Cobertura",
       subtitle = "Nivel provincia",
       x = "Cobertura",
       y = "IDH")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 4, nudge_y = 0.05, size=2, check_overlap = T)
ggMarginal(plot_idh_provincia, type = "boxplot")

cortest_idh_provincia <- cor.test(pobreza_provincia$IDH, pobreza_provincia$cobertura)

```

Contrariamente a la correlación observada con el Indicador de IDH, se observa una correlación negativa del Indicador de Necesidades Básicas Insatisfechas (NBI) con Cobertura, debido a que a este se interpreta de manera inversa, es decir, a mayor NBI, mayor índice de pobreza; sin embargo, esta correlación no es estadísticamente significativa (r(23) = -0.14, p > 0.5). 

```{r pobreza nbi departamento, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#NBI departameto
nbi <- read_xlsx("raw/NBI_2017.xlsx")
nbi$Departamento <- toupper(nbi$Departamento)
nbi_departamento <- left_join(llamadas_departamento, nbi, by = "Departamento")

plot_nbi <- ggplot2::ggplot(nbi_departamento, aes(cobertura, NBI_2017, label = Departamento)) +
  geom_jitter() + 
  labs("Necesidades básicas insatisfechas vs. Cobertura",
       subtitle = "Nivel departamento",
       x = "Cobertura",
       y = "NBI")+
  geom_smooth(method = "lm", se = FALSE) +
  geom_text(vjust = 1.5, nudge_y = 0.2, size=3, check_overlap = T)
ggMarginal(plot_nbi, type = "boxplot")

cortest_nbi_departamento <- cor.test(nbi_departamento$cobertura, nbi_departamento$NBI_2017)

```


### Cobertura y fallecimientos COVID

<!-- fecha de corte de fallecimientos es el 22 de noviembre ahora-->
<!-- Le puse la fecha de corte del 27.11.¿Es mejor?-->

El **Índice de Fallecimientos** se compone del Número de fallecimientos -hasta la fecha de corte del **27 de noviembre del año 2020**- de acuerdo a los tres niveles analizados ponderado por la población de adultos mayores.

La fórmula a nivel departamental, por ejemplo, es la siguiente:

$IndiceFallecimientos_{departamento}  = \frac{NúmeroFallecimientos_{departamento}}{PoblaciónAdultaMayor_{departamento}}$

```{r fallecimientos limpieza, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#Limpieza de bbdd de fallecimiento

fallecidos_covid <- read.csv2("raw/fallecidos_covid_27_11.csv")
fallecidos_covid$string <- paste(fallecidos_covid$DEPARTAMENTO, fallecidos_covid$PROVINCIA, fallecidos_covid$DISTRITO, sep="")
cols <- colnames(llamadas_distrito)
llamadas_distrito[, cols] <- apply(llamadas_distrito[, cols], 2, function(x) toupper(x))
llamadas_distrito$Distrito <- gsub("_", "-", llamadas_distrito$Distrito)
llamadas_distrito$Distrito[llamadas_distrito$Distrito == "SANTA CRUZ DE TOLED"] <- "SANTA CRUZ DE TOLEDO"

llamadas_distrito$Distrito <- gsub("Á", "A", llamadas_distrito$Distrito)
llamadas_distrito$Distrito <- gsub("É", "E", llamadas_distrito$Distrito)
llamadas_distrito$Distrito <- gsub("Í", "I", llamadas_distrito$Distrito)
llamadas_distrito$Distrito <- gsub("Ó", "O", llamadas_distrito$Distrito)
llamadas_distrito$Distrito <- gsub("Ú", "U", llamadas_distrito$Distrito)

llamadas_distrito$Provincia <- gsub("Á", "A", llamadas_distrito$Provincia)
llamadas_distrito$Provincia <- gsub("É", "E", llamadas_distrito$Provincia)
llamadas_distrito$Provincia <- gsub("Í", "I", llamadas_distrito$Provincia)
llamadas_distrito$Provincia <- gsub("Ó", "O", llamadas_distrito$Provincia)
llamadas_distrito$Provincia <- gsub("Ú", "U", llamadas_distrito$Provincia)

llamadas_distrito$Departamento <- gsub("Á", "A", llamadas_distrito$Departamento)
llamadas_distrito$Departamento <- gsub("É", "E", llamadas_distrito$Departamento)
llamadas_distrito$Departamento <- gsub("Í", "I", llamadas_distrito$Departamento)
llamadas_distrito$Departamento <- gsub("Ó", "O", llamadas_distrito$Departamento)
llamadas_distrito$Departamento <- gsub("Ú", "U", llamadas_distrito$Departamento)

llamadas_distrito$string <- paste(llamadas_distrito$Departamento, llamadas_distrito$Provincia, llamadas_distrito$Distrito, sep = "")
fallecidos_covid$string <- plyr::mapvalues(x = fallecidos_covid$string, from = llamadas_distrito$string, to = llamadas_distrito$UBIGEO_distrito)

fallecidos_covid <- fallecidos_covid[!is.na(fallecidos_covid$PROVINCIA), ]
fallecidos_covid <- fallecidos_covid[!is.na(fallecidos_covid$DISTRITO), ]
colnames(fallecidos_covid)[colnames(fallecidos_covid) == "string"] <- "UBIGEO_distrito"
fallecidos_covid$contar <- 1
```

La correlación a nivel departamental entre las variables **Índice de fallecimientos** y **Cobertura de llamadas** es positiva y significativa (r(23)= 0.34, p < 0.5). Por otro lado, los departamentos con menor performance son Ica, Loreto y Tumbes por encima de la línea de regresión, mientras que Puno, Apurímac, Huancavelica, Tacna y Pasco, por debajo. 

```{r fallecimientos departamento, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#Nivel departamento

fallecidos_covid_departamento <- aggregate(fallecidos_covid$contar, by=list(fallecidos_covid$DEPARTAMENTO), sum)
colnames(fallecidos_covid_departamento)[1] <- "Departamento"
colnames(fallecidos_covid_departamento)[2] <- "N_fallecidos"
fallecidos_covid_departamento <- left_join(llamadas_departamento, fallecidos_covid_departamento, by="Departamento")
fallecidos_covid_departamento$cobertura <- as.numeric(fallecidos_covid_departamento$cobertura)

poblacion <- readxl::read_xlsx("raw/Poblacion Peru 2020 Dpto Prov Dist Final INEI-actualizado.xlsx")
poblacion$adultos_mayores <- poblacion$`65-69`+poblacion$`70-74`+poblacion$`75-79`+poblacion$`80 y +`
colnames(poblacion)[1] <- "UBIGEO_distrito"
pobmayor_departamento <- aggregate(poblacion$adultos_mayores, by = list(poblacion$DEPARTAMENTO), sum)
colnames(pobmayor_departamento)[1] <- "Departamento"
colnames(pobmayor_departamento)[2] <- "Poblacion_mayor"

fallecidos_covid_departamento <- left_join(fallecidos_covid_departamento, pobmayor_departamento, by = "Departamento")
fallecidos_covid_departamento$N_fallecidos <- fallecidos_covid_departamento$N_fallecidos/fallecidos_covid_departamento$Poblacion_mayor

plot_fallecimientos_departamento <- ggplot2::ggplot(fallecidos_covid_departamento, aes(cobertura, N_fallecidos, label = Departamento))+
  geom_jitter()+
  labs(title= "Índice de fallecimientos",
       subtitle = "Nivel departamento",
       x = "Cobertura",
       y = "Índice de fallecimientos")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.005, nudge_y = 0.0005, size=2, check_overlap = T)
ggMarginal(plot_fallecimientos_departamento, type = "boxplot", fill="transparent")

cortest_fallecimiento_departamento <- cor.test(fallecidos_covid_departamento$cobertura, fallecidos_covid_departamento$N_fallecidos)

```

Enfocándonos en el nivel provincial, encontramos que la correlación entre ambas variables es muy baja, aunque estadísticamente significativa. Esta es: r(190) = 0.14 (p > 0.05). Por otro lado, la provincia San Martín aparece como **outlier** en ambos índices. Asimismo, varias provincias se encuentran por encima de la línea de predicción, por lo que no se observa una correlación fuerte, como lo indica también el índice de correlación de Pearson. 


```{r fallecimientos provincia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#Nivel provincial

fallecidos_covid_provincia <- aggregate(fallecidos_covid$contar, by=list(fallecidos_covid$PROVINCIA), sum)
colnames(fallecidos_covid_provincia)[1] <- "Provincia"
colnames(fallecidos_covid_provincia)[2] <- "N_fallecidos"
fallecidos_covid_provincia <- left_join(llamadas_provincia, fallecidos_covid_provincia, by="Provincia")
fallecidos_covid_provincia$cobertura <- as.numeric(fallecidos_covid_provincia$cobertura)

pobmayor_provincia <- aggregate(poblacion$adultos_mayores, by = list(poblacion$PROVINCIA), sum)
colnames(pobmayor_provincia)[1] <- "Provincia"
colnames(pobmayor_provincia)[2] <- "Poblacion_mayor"
fallecidos_covid_provincia <- left_join(fallecidos_covid_provincia, pobmayor_provincia, by = "Provincia")
fallecidos_covid_provincia$N_fallecidos <- fallecidos_covid_provincia$N_fallecidos/fallecidos_covid_provincia$Poblacion_mayor

plot_fallecimientos_provincia <- ggplot2::ggplot(fallecidos_covid_provincia, aes(cobertura, N_fallecidos, label = Provincia))+
  geom_point()+
  labs(title= "Índice de fallecimientos",
       subtitle = "Nivel provincial",
       x = "Cobertura",
       y = "Índice de fallecimientos") +
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.005, nudge_y = 0.001, size=2, check_overlap = T)
ggMarginal(plot_fallecimientos_provincia, type = "boxplot", fill="transparent")

cortest_fallecimiento_provincia <- cor.test(fallecidos_covid_provincia$cobertura, fallecidos_covid_provincia$N_fallecidos)
```

Finalmente, realizando el mismo análisis a nivel distrital observamos que la una baja correlación, aunque significativa, r(1194) = 0.09, p < 0.01. La mayoría de distritos se encuentran por encima de la línea de predicción, siendo Churuja (Bongara, Amazonas) aquel con mayor alejamiento. Por otro lado, los distritos de Suitucancha (Yauli, Junín), Tarapoto (San Martín, San Martín) y Juanji(Mariscal Cáceres, San Martín) se compartan como *outliers* en ambas variables. 

```{r fallecimientos dsitrito, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#Nivel distrital

fallecidos_covid_distrito <- aggregate(fallecidos_covid$contar, by=list(fallecidos_covid$UBIGEO_distrito), sum)
colnames(fallecidos_covid_distrito)[1] <- "UBIGEO_distrito"
colnames(fallecidos_covid_distrito)[2] <- "N_fallecidos"
fallecidos_covid_distrito <- left_join(llamadas_distrito, fallecidos_covid_distrito, by="UBIGEO_distrito")
fallecidos_covid_distrito$cobertura <- as.numeric(fallecidos_covid_distrito$cobertura)

pobmayor_distrito <- aggregate(poblacion$adultos_mayores, by = list(poblacion$DISTRITO), sum)
colnames(pobmayor_distrito)[1] <- "Distrito"
colnames(pobmayor_distrito)[2] <- "Poblacion_mayor"
fallecidos_covid_distrito <- left_join(fallecidos_covid_distrito, pobmayor_distrito, by = "Distrito")
fallecidos_covid_distrito$N_fallecidos <- fallecidos_covid_distrito$N_fallecidos/fallecidos_covid_distrito$Poblacion_mayor

plot_fallecimientos_distrito <- ggplot2::ggplot(fallecidos_covid_distrito, aes(cobertura, N_fallecidos, label = Distrito))+
  geom_jitter()+
  labs(title= "Índice de fallecimientos",
       subtitle = "Nivel distrital",
       x = "Cobertura",
       y = "Índice de fallecimientos")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.005, nudge_y = .001, size=2, check_overlap = T)
ggMarginal(plot_fallecimientos_distrito, type = "boxplot", fill="transparent")

cortest_fallecimiento_distrito <- cor.test(fallecidos_covid_distrito$cobertura, fallecidos_covid_distrito$N_fallecidos)

```

## Violencia

En términos generales, no existen departamentos que reporten un porcentaje mayor a 0.2% en alguna de las variables de violencia. En la mayoría de casos, se reporta ningún tipo de violencia. Es necesario, de todas formas, acotar que Ica es quien tiene el mayor índice de violencia (0.2%). 

```{r violencia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

a <- colnames(visitas[, c(31:35, 48)])

visitas[, a] <- apply(visitas[, a], 2, function(x) mapvalues(x, c("NO", "SI"), c(0, 1)))

visitas[, a] <- apply(visitas[, a], 2, function(x) as.numeric(x))

visitas %>% 
  dplyr::select(c(2,31:35, 48)) %>% 
  tbl_summary(by=departamento,missing = "no",
              percent = "column")

```


## Indicador de salud

El índicador de salud escogido en esta sección es proporcionado por la base de datos del Repositorio Único Nacional de Información en Salud (REUNIS), de la cual se tomó la variable de morbilidad de Infecciones agudas de las vías respiratorias superiores en adultos mayores. Luego, el número de estas infecciones se dividió entre la población de adultos mayores de la unidad de análisis.

La fórmula para el indicador de salud, por ejemplo, para la unidad de análisis de departamento es la siguiente:

$IndiceDeSalud_{departamento}  = \frac{NumeroDeAdultosMayoresInfectados_{departamento}}{PoblacionAdultaMayor_{departamento}}$

El indicador de salud señalado previamente no muestra una correlación con la cobertura de llamadas a nivel departamental. Por otro lado, se aprecia que los departamentos de Amazonas, Huancavelica, Apurímac y Ayacucho se compartan como *outliers* respecto al indicador de salud.

```{r salud departamento, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
salud <- readxl::read_xlsx("raw/Dpto_Filtro_Datos_completos_data.xlsx")
salud$UBIGEO_departamento <- salud$Departamento
salud$contar <- 1
salud <- salud[salud$`Etapa de Vida`== "60a>", ]
salud_departamento <- aggregate(salud$contar, by = list(salud$UBIGEO_departamento), sum)
colnames(salud_departamento)[1] <- "UBIGEO_departamento"
colnames(salud_departamento)[2] <- "N_infecciones_respiratorias"

salud_departamento <-  merge(salud_departamento, salud[, c("Altitud", "UBIGEO_departamento")], by.x = "UBIGEO_departamento", all.x = TRUE)
a <- !duplicated(salud_departamento$UBIGEO_departamento)
salud_departamento <- salud_departamento[a, ]

salud_departamento$UBIGEO_departamento <- plyr::mapvalues(x = salud_departamento$UBIGEO_departamento, from = llamadas_departamento$Departamento, to = llamadas_departamento$UBIGEO_departamento)
salud_departamento <- left_join(llamadas_departamento, salud_departamento, by = "UBIGEO_departamento")
salud_departamento$cobertura <- as.numeric(salud_departamento$cobertura)
salud_departamento <- left_join(salud_departamento, pobmayor_departamento, by = "Departamento")
salud_departamento$N_infecciones_respiratorias <- salud_departamento$N_infecciones_respiratorias/salud_departamento$Poblacion_mayor

plot_salud_departamento <- ggplot2::ggplot(salud_departamento, aes(cobertura, N_infecciones_respiratorias, label = Departamento))+
  geom_jitter()+
  labs(title= "Indicador de salud",
       subtitle = "Nivel departamento",
       x = "Cobertura",
       y = "Infecciones respiratorias")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.1, nudge_y = 0.0005, size=2, check_overlap = T)
ggMarginal(plot_salud_departamento, type = "boxplot", fill="transparent")

cortest_salud_departamento <- cor.test(salud_departamento$N_infecciones_respiratorias, salud_departamento$cobertura)


```

La correlación a nivel provincial de ambas variables es muy baja, positiva y no es significativa. Por lo que no se puede afirmar estadísticamente que exista una correlación entre ambas variables (r(193) = 0.13, p > 0.5). 
Por otro lado, las provincias *outliers* positivas de la variable Indicador de salud (i.e. con mayores casos de infecciones respiratorias) son Castrovirreyna (Huancavelica), Paucar del Sara Sara (Ayacucho), Putumayo (Loreto) y Sucre (Ayacucho). 

```{r salud provincia, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

salud$UBIGEO_provincia <- paste(salud$Departamento, salud$Provincia, sep = "")
salud$contar <- 1
salud <- salud[salud$`Etapa de Vida`== "60a>", ]
salud_provincia <- aggregate(salud$contar, by = list(salud$UBIGEO_provincia), sum)
colnames(salud_provincia)[1] <- "UBIGEO_provincia"
colnames(salud_provincia)[2] <- "N_infecciones_respiratorias"

salud_provincia <-  merge(salud_provincia, salud[, c("Altitud", "UBIGEO_provincia")], by.x = "UBIGEO_provincia", all.x = TRUE)
a <- !duplicated(salud_provincia$UBIGEO_provincia)
salud_provincia <- salud_provincia[a, ]

llamadas_provincia$string <- paste(llamadas_provincia$Departamento, llamadas_provincia$Provincia, sep = "")
salud_provincia$UBIGEO_provincia <- plyr::mapvalues(x = salud_provincia$UBIGEO_provincia, from = llamadas_provincia$string, to = llamadas_provincia$UBIGEO_provincia)
salud_provincia <- left_join(llamadas_provincia, salud_provincia, by = "UBIGEO_provincia")
salud_provincia$cobertura <- as.numeric(salud_provincia$cobertura)
salud_provincia <- left_join(salud_provincia, pobmayor_provincia, by = "Provincia")
salud_provincia$N_infecciones_respiratorias <- salud_provincia$N_infecciones_respiratorias/salud_provincia$Poblacion_mayor

plot_salud_provincia <- ggplot2::ggplot(salud_provincia, aes(cobertura, N_infecciones_respiratorias, label = Provincia))+
  geom_jitter()+
  labs(title= "Indicador de salud",
       subtitle = "Nivel provincia",
       x = "Cobertura",
       y = "Infecciones respiratorias")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.005, nudge_y = 0.001, size=2, check_overlap = T)
ggMarginal(plot_salud_provincia, type = "boxplot", fill="transparent")

cortest_salud_provincia <- cor.test(salud_provincia$cobertura, salud_provincia$N_infecciones_respiratorias)

```

Existe una correlación significativa y positiva entre ambas variables, pero muy baja. Esta es: r(1834) = 0.11 (p < 0.001). En ese sentido, se observan varios distritos alejados de la línea de regresión. Por otro lado, resaltan los distritos de Sonche, Morococha y Chacapalpa como *outliers* en ambas variables al mismo tiempo. 

```{r salud distrito, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

salud$UBIGEO_distrito <- paste(salud$Departamento, salud$Provincia, salud$Distrito, sep = "")
salud$contar <- 1
salud <- salud[salud$`Etapa de Vida`== "60a>", ]
salud_distrito <- aggregate(salud$contar, by = list(salud$UBIGEO_distrito), sum)
colnames(salud_distrito)[1] <- "UBIGEO_distrito"
colnames(salud_distrito)[2] <- "N_infecciones_respiratorias"

salud_distrito <-  merge(salud_distrito, salud[, c("Altitud", "UBIGEO_distrito")], by.x = "UBIGEO_distrito", all.x = TRUE)
a <- !duplicated(salud_distrito$UBIGEO_distrito)
salud_distrito <- salud_distrito[a, ]

llamadas_distrito$string <- paste(llamadas_distrito$Departamento, llamadas_distrito$Provincia, llamadas_distrito$Distrito, sep = "")
salud_distrito$UBIGEO_distrito <- plyr::mapvalues(x = salud_distrito$UBIGEO_distrito, from = llamadas_distrito$string, to = llamadas_distrito$UBIGEO_distrito)

salud_distrito <- left_join(llamadas_distrito, salud_distrito, by = "UBIGEO_distrito")
salud_distrito$cobertura <- as.numeric(salud_distrito$cobertura)
salud_distrito <- left_join(salud_distrito, pobmayor_distrito, by = "Distrito")
salud_distrito$N_infecciones_respiratorias <- salud_distrito$N_infecciones_respiratorias/salud_distrito$Poblacion_mayor

plot_salud_distrito <- ggplot2::ggplot(salud_distrito, aes(cobertura, N_infecciones_respiratorias, label = Distrito))+
  geom_jitter()+
  labs(title= "Indicador de salud",
       subtitle = "Nivel distrito",
       x = "Cobertura",
       y = "Infecciones respiratorias")+
  geom_smooth(method = "lm", se = FALSE, na.rm = T) +
  geom_text(vjust = 0.005, nudge_y = 0.001, size=2, check_overlap = T)
ggMarginal(plot_salud_distrito, type = "boxplot", fill="transparent")

cortest_salud_distrito <- cor.test(salud_distrito$cobertura, salud_distrito$N_infecciones_respiratorias)

```

## Análisis inferencial exploratorio

Finalmente, a modo de ejercicio exploratorio, oresentamos aquí un análisis inferencial donde se evidencia una asociación ligeramente positiva entre la cobertura de las llamadas y el número de infecciones respiratorias, luego de controlar por promedio de altitud de cada distrito y porcentaje de población de adultos mayores. Ello sugiere que las visitas remotas se asocian ligeramente a aquellos distritos con mayor incidencia de casos de enfermedades respiratorias.

```{r analisis inferencial, results = "asis", echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

poblacion <- readxl::read_xlsx("raw/Poblacion Peru 2020 Dpto Prov Dist Final INEI-actualizado.xlsx")
poblacion$adultos_mayores <- poblacion$`65-69`+poblacion$`70-74`+poblacion$`75-79`+poblacion$`80 y +`
colnames(poblacion)[1] <- "UBIGEO_distrito"
salud_distrito <- merge(salud_distrito, poblacion, by = "UBIGEO_distrito", all.x = TRUE)

#Regresion
#variable.names(salud_distrito)
regresion_salud <- lm(N_infecciones_respiratorias ~ cobertura +
                        Altitud + adultos_mayores,
                      data=salud_distrito)
stargazer(regresion_salud, type = "latex")

```

# Conclusiones

Aunque la mayoría de variables presentadas cuenta con información confiable, existe un grupo de variables que presentan valores errados o confusos. Ello ocurre debido a problemas en el ingreso de los datos, probablemente debido a opciones automatizadas. También encuentránse algunos casos de un elevado número de respuestas faltantes, lo que podría ser corregido en el instrumento que captura datos. Cualquier análisis de datos ha de considerar dichos casos de cara a corregir posibles graves inferencias en base a errores de captura de los datos.

Considerando el valioso aporte y rol de las visitas remotas, el análisis estadístico no encuentra asociaciones claras entre indicadores vinculados a pobreza o salud (que hipotéticamente podrían ser planteados como criterios de priorización) y la cobertura de las llamadas/beneficiarios.

La variable con menor respuesta es la referente a la salud mental de los beneficiarios, seguido de educación financiera. Ello sugiere la necesidad de abordar las dificultades en tratar ambos temas en la fase cualitativa del estudio.

Los departamentos de San Martín y Moquegua sobresalen positivamente en términos de llamadas por beneficiario, mientras que Tumbes y Cajamarca son las regiones donde se encuentra la mayor proporción de reportes de morbilidades.

Los departamentos de San Martín, Ancash y Lima presentan los mejores índice de cobertura de llamadas, mientras que departamentos como Loreto, Cusco, Piura y Puno se comportan en la dirección opuesta.

A partir del análisis realizado, se sugiere enfocar la fase cualitativa del estudio en los departamentos de Moquegua o San Martín (como caso positivo) así como también Apurimac  o Puno (como caso negativo).

